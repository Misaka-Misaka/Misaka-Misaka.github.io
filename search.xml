<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态更新的数论学习笔记</title>
      <link href="/2019/12/17/dong-tai-geng-xin-de-shu-lun-xue-xi-bi-ji/"/>
      <url>/2019/12/17/dong-tai-geng-xin-de-shu-lun-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><hr><hr><h2 id="因数"><a href="#因数" class="headerlink" title="因数"></a>因数</h2><ul><li>欧几里得算法：   <ul><li>求$a,b$最大公因数$gcd(a,b)$<br>太过简单，只给代码(llo为long\ long):  <pre class=" language-cpp"><code class="language-cpp">      llo <span class="token function">gcd</span><span class="token punctuation">(</span>llo a<span class="token punctuation">,</span> llo b<span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li>求$a,b$最小公倍数$lcm(a,b)$<br>$$lcm(a,b)=\frac{a*b}{gcd(a,b)}$$  </li></ul></li></ul><hr><ul><li>分解质因数<pre class=" language-cpp"><code class="language-cpp">      <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">1ll</span> <span class="token operator">*</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              p<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>              t<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">++</span>t<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">;</span> x <span class="token operator">/</span><span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span> p<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> t<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>从小到大枚举，对于任意质数，直接进行代码所示的枚 举而对于合数来说，它一定是由较小的质数组成，即使 原$x$ % (这个数) $==$ $0$，但$x$经过前面的处理已经将这个组  成这个合数的因子除掉了，自然当前$x$ % (这个数) $!=$ $0$</p></blockquote></li></ul><hr><ul><li><p>最小质因子：  </p><ul><li><p>求解方法：对筛法求素数代码进行改变  </p></li><li><p>代码：  </p><pre class=" language-cpp"><code class="language-cpp">      <span class="token function">memset</span><span class="token punctuation">(</span>sf<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">memset</span><span class="token punctuation">(</span>mindiv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>mindiv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      n <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>          mindiv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>              f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mindiv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> mindiv<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span></code></pre><blockquote><p>对于每个数，由于是从小向大枚举，则它的最小质因子一定是最先能够筛掉它的数   </p></blockquote></li><li><p>利用最小质因子求出所有质因子：<br>  设$minx$为$x$的最小质因子，则显然$x = (x / minx) × minx$，设$miny$为$(x / minx)$的最小质因子，又有$(x / minx) = (x / minx / miny) × miny$这样递归下去即可求出$x$的所有质因子</p></li><li><p>$2$ ~ $n$每个数的质因子个数<br>  $$f[1] = 0, f[x] = f[x / mindivx] + 1$$</p></li><li><p>$2$ ~ $n$每个数的不同质因子个数<br>  $$f[1] = 0,f[x] = f[x / mindivx] + mindivx \mod  (x / mindivx) ? 0 : 1$$</p></li></ul></li></ul><hr><ul><li>快速求$1$~$n$所有数的因子：  <ul><li>$1$~$n$的因子总数为$nlogn$ $(n / 1 + n / 2 + n / 3 + n / 4 + …… n / n)$</li><li>代码：  <pre class=" language-cpp"><code class="language-cpp">      vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> div<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          div<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">)</span>              div<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span></code></pre><blockquote><p>类似于筛法思想，将当前数的所有倍数添加当前数为因子， 时间空间都是$O(nlogn)$的 </p></blockquote></li></ul></li></ul><hr><ul><li>精确的求某一个数的所有因子：质因数分解 $+$ 指数搜索<blockquote><p>例：$100 = 2^2 × 5^2$<br>因子：$2^0 × 5^0, 2^1 × 5^0……$  </p></blockquote></li></ul><hr><hr><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><ul><li>线性筛：<pre class=" language-cpp"><code class="language-cpp">      <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token function">memset</span><span class="token punctuation">(</span>sf<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>sf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>              sf<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span> sf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><blockquote><p>对于一个数，只要有一个质数将它筛去即可确定是合数，所以对于每个数$x$，将当前素数表里不大于$mindivx$的数与$x$的乘积筛掉，而大于$mindivx$的质数与$x$的乘积必定会在之后被大于x的数筛掉，减小了筛的次数，达到线性的复杂度 $(注意两个break的次序和位置)$，适用于$n &gt; 1e7$的数据范围  </p></blockquote></li></ul><hr><hr><h2 id="一些我不知道怎么分类但是非常强大的算法"><a href="#一些我不知道怎么分类但是非常强大的算法" class="headerlink" title="一些我不知道怎么分类但是非常强大的算法"></a>一些我不知道怎么分类但是非常强大的算法</h2><ul><li><p>扩展欧几里得算法$(exgcd)$：  </p><ul><li><p><del>我自闭了</del>  </p></li><li><p>对扩欧的理解：  </p><p>给出不定方程,形如  </p><p>$$ax+by=c$$  </p><p>满足条件的<strong>整数解</strong>$x,y$有很多(<del>废话</del>)，当且仅当$gcd(a,b)|c$时方程有整数解   </p><blockquote><p>证明：<br>方程两边同时除以$gcd(a,b)$    </p></blockquote><p>$$\frac{a}{gcd(a,b)}* x+\frac{b}{gcd(a,b)}*y=\frac{c}{gcd(a,b)}$$</p><blockquote><p>观察等式，等式左边为一整数，故等式右边亦为一整数<br>所以  </p></blockquote><p>$$gcd(a,b)|c$$  </p><blockquote><p>证毕  </p></blockquote><p>因此，可以转化为求一组$x,y$，满足$ax+by=gcd(a,b)$，在求解原方程等式两边同时乘以$\frac{c}{gcd(a,b)}$即可<br>对于求解$ax+by=gcd(a,b)$，可以找出一组$x0,y0$<br>使<br>$$ax_0+by_0=gcd(a,b)$$<br>进而表达出通解公式：  </p><p>$$x=x_0+t*\frac{b}{gcd(a,b)}$$  </p><p>$$\qquad \qquad \quad y=y_0-t*\frac{a}{gcd(a,b)},\quad\forall t\in Z$$  </p><blockquote><p>推导过程：<br>$$ax_0 + by_0$$<br>$$=ax_0+\frac{a* b}{gcd(a,b)}+by_0-\frac{b* a}{gcd(a,b)}$$<br>$$=a(x_0+\frac{b}{gcd(a,b)})+b(y_0-\frac{a}{gcd(a,b)})$$<br>$$ax+by=a(x_0+t* \frac{b}{gcd(a,b)})+b(y_0-t* \frac{a}{gcd(a,b)}),\quad \forall t\in Z$$<br>因此，若要表达其它满足方程的$x,y$<br>$$x=x_0+t* \frac{b}{gcd(a,b)}$$<br>$$\qquad \qquad \quad y=y_0-t*\frac{a}{gcd(a,b)},\quad\forall t\in Z$$<br>推毕   </p></blockquote><p>那么只需要求出一组特解$x_0,y_0$就好了，而求解特解，便是扩欧算法的核心所在<br>代码(<del>因为怂</del>都开了$long\ long$)：    </p><pre class=" language-cpp"><code class="language-cpp">  llo <span class="token function">exgcd</span><span class="token punctuation">(</span>llo a<span class="token punctuation">,</span> llo b<span class="token punctuation">,</span> llo <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> llo y<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span>      llo gcd <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>      llo z <span class="token operator">=</span> x<span class="token punctuation">,</span> x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> z <span class="token operator">-</span> y <span class="token operator">*</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><blockquote><p>解释：<br>在欧几里得算法中，每一个状态$a,b$的下一个状态是$b,a\mod b$<br>假设当前状态的下一个状态中已经求解出一组$x_1,y_1$<br>$$b* x_1+a\mod b* y_1=gcd(a,b)$$<br>因为<br>$$a\mod b=a-(a/b)* b$$<br>所以<br>$$b* x_1+(a-(a/ b)* b)* y1=gcd(a,b)$$<br>$$b* x_1-(a/b)* b* y_1+a* y_1=gcd(a,b)$$<br>$$a* y_1+b[x_1-(a/b)* y_1]=gcd(a,b)$$<br>那么在递归返回时可令<br>$$x=y1,y=x_1-(a/b)* y_1$$<br>欧几里得算法停止的状态，$b=0$，此时时$a$即为$gcd(a,b)$  若使$a$的系数为$1$那么$b$的系数y便无关紧要了<br>$$1* gcd(a,b)+k* 0=gcd(a,b)$$<br>所以<br>$$if(!b),x=1,y=k\quad \forall k\in Z$$<br>为了方便使$y=0$<br>注意：$x,y$是传址调用，否则无法起到递归返回时修改的目的   </p></blockquote><p>$exgcd$算法的流程便结束了    </p></li><li><p>exgcd的应用：  </p><ul><li><p>求最小整数解：  </p><p>回顾原方程：<br>$$ax+by=gcd(a,b)$$<br>$x$的最小整数解$min_x=x\mod  \frac{b}{gcd(a,b)}$  </p><blockquote><p>推导：<br>假设$exgcd$求出原方程的一组解为$x_0,y_0$<br>由于解集之间可以相互转化<br>$$x_0=min_x+t*\frac{b}{gcd(a,b)}$$<br>要求解$min_x$只需要$x_0\mod \frac{b}{gcd(a,b)}$即可  </p></blockquote></li><li><p>求解$a$在$mod\ p$意义下的逆元(a^{-1})：  </p><blockquote><p>逆元：<br>对于一个实数$a$，如果存在一个$x$使得 $ax=1$，我们就把这个$x$叫做$a$的逆元，记做$x=a^{-1}$<br>在一般数学中，我们所说的逆元就是倒数。<br>在数论中，如果数字$a$存在一个对$p$的逆元$x$，可以写成$ax\equiv 1\ (mod\ p)$，$gcd(a,p)=1$，否则不存在逆元</p></blockquote><p>设$a^{-1}$为$x$，原式转化为<br>$$ax\equiv 1\ (mod\ p)$$<br>进而转化为<br>$$ax+py=1$$<br>$exgcd$解决  </p><p>代码(exgcd求解出的x是负数，return时需要处理)：</p><pre class=" language-cpp"><code class="language-cpp">  llo <span class="token function">inv</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>      llo x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> p <span class="token operator">+</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre></li><li><p>线性同余方程：  </p><p>一般形式<br>$$ax\equiv b\ (mod\ p)$$<br>对此一定有$b&lt;p$，而$b&gt;p$时可先对$b$取模，等效<br>式子可转化<br>$$ax-kp=b$$<br>$exgcd$求解  </p></li></ul></li><li><p>例题：  </p><ul><li><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">$luogu\ p1082$ 同余方程</a> ：模板题  </li><li><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">$luogu\ p1516$ 青蛙的约会</a> ：先列出式子，套$exgcd$  </li></ul></li></ul></li></ul><hr><ul><li><p>费马小定理：  </p><ul><li><p>定义：若$p$为一质数，则$a^{p-1}\equiv 1\ (mod\ p)$  </p></li><li><p>费马小定理求逆元：  </p><p>由定义上式可转化为<br>$$a*a^{p-2}\equiv 1\ (mod\ p)$$<br>因此$a^{p-2}$即为$a$在$mod\ p$意义下的逆元<br>可以直接用快速幂求解   </p></li></ul></li></ul><hr><ul><li>高斯消元：  <ul><li>定义</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2018/09/07/hello-world/"/>
      <url>/2018/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
