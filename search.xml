<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模板整合</title>
      <link href="/2019/12/17/mo-ban-zheng-he/"/>
      <url>/2019/12/17/mo-ban-zheng-he/</url>
      
        <content type="html"><![CDATA[<p>自己认为模板在算法竞赛中还是比较重要的.<br>它能够帮助你快速的回忆起一种算法的框架<br>但OI的题目千变万化，模板只能做个参考  </p><hr><hr><h2 id="tarjan-算法"><a href="#tarjan-算法" class="headerlink" title="$tarjan$算法"></a>$tarjan$算法</h2><h3 id="求强联通分量"><a href="#求强联通分量" class="headerlink" title="求强联通分量"></a>求强联通分量</h3><pre><code>int dfn[N], low[N], scc[M], color[N];stack &lt;int&gt; sta;int time_cnt, scc_cnt;void tarjan(int u) {    dfn[u] = low[u] = ++time_cnt, sta.push(u);    for (int i = hd[u]; i; i = e[i].nt) {        int v = e[i].to;        if (!dfn[v])            tarjan(v), low[u] = min(low[u], low[v]);        else if (!color[v])            low[u] = min(low[u], dfn[v]);    }    if (dfn[u] == low[u]) {        ++scc_cnt;         color[u] = scc_cnt;        scc[scc_cnt]++;        while (s.top() != u) {            color[s.top()] = scc_cnt;            scc[scc_cnt]++; sta.pop();        } sta.pop();    }}</code></pre><hr><h2 id="DP-常用模板"><a href="#DP-常用模板" class="headerlink" title="$DP$常用模板"></a>$DP$常用模板</h2><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><blockquote><blockquote><p>$01$背包问题：</p></blockquote></blockquote><pre><code>for (int i = 1; i &lt;= n; i++)    for (int j = V; j &gt;= v[i]; j--)        dp[j] = max(dp[j], dp[j - v[i]] + c[i]);</code></pre><blockquote><blockquote><p>完全背包：</p></blockquote></blockquote><pre><code>for (int i = 1; i &lt;= n; i++)    for (int j = v[i]; j &lt;= V; j++)        dp[j] = max(dp[j], dp[j - v[i]] + c[i]);</code></pre><blockquote><blockquote><p>多重背包：</p></blockquote></blockquote><pre><code>for (int i = 1; i &lt;= n; i++)    for (int j = V; j &gt;= v[i]; j--)        for (int k = 0; k &lt;= s[i]; k++)            dp[j] = max(dp[j], dp[j - k * v[i]] + k * c[i]);</code></pre><blockquote><blockquote><p>混合背包：</p></blockquote></blockquote><pre><code>for (int i = 1; i &lt;= n; i++) {    if (p[i] == 0)        for (int j = v[i]; j &lt;= V; j++)            dp[j] = max(dp[j], dp[j - v[i]] + c[i]);    else        for (int k = 1; k &lt;= p[i]; k++)            for (int j = V; j &gt;= v[i]; j--)                dp[j] = max(dp[j], dp[j - v[i]] + c[i]);}</code></pre><blockquote><blockquote><p>二维背包：</p></blockquote></blockquote><pre><code>for (int i = 1; i &lt;= n; i++)    for (int j = V; j &gt;= v[i]; j--)        for (int q = U; q &gt;= u[i]; q--)            dp[j][q] = max(dp[j][q], dp[j - v[i]][q - u[i]] + c[i]);</code></pre><blockquote><blockquote><p>分组背包：</p></blockquote></blockquote><pre><code>for (int k = 1; k &lt;= t; k++)    for (int j = V; j &gt;= v[a[k][i]]; j--)        for (int i = 1; i &lt;= a[k][0]; i++)            dp[j] = max(dp[j], dp[j - v[a[k][i]]] + c[a[k][i]]);</code></pre><blockquote><blockquote><p>方案背包：</p></blockquote></blockquote><pre><code>dp[0] = 1;for (int i = 1; i &lt;= n; i++)    for (int j = v[i]; j &lt;= V; j++)        dp[j] += dp[j - v[i]];</code></pre><ul><li>二进制优化：</li></ul><pre><code>    for(int i=1;i&lt;=n;i++)    {        int x,y,s,t=1;        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;s);        while(s&gt;=t)        {            v[nl++]=x*t;c[nl]=y*t;            s-=t;            t*=2;        }        v[nl++]=x*s;c[nl]=y*s;    }</code></pre><hr><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><pre><code>for (int len = 2; len &lt;= n; len++)    for (int l = 1; l + len - 1 &lt;= n; l++) {        int r = l + len - 1;        if (j &gt; n) break;        for (int k = l; k &lt; r; k++)            dp[l][r] = max(dp[l][r], dp[l][k] + dp[k + 1][r] + w[l][r]);    }</code></pre><h3 id="最长不下降子序列-LIS"><a href="#最长不下降子序列-LIS" class="headerlink" title="最长不下降子序列(LIS)"></a>最长不下降子序列(LIS)</h3><pre><code>for (int i = n - 1; i &gt;= 1; i--) {    l = 0, k = 0;    for (int j = i + 1; j &lt;= n; j++)        if (dp[j][1] &gt; dp[i][1] &amp;&amp; dp[j][2] &gt; l)            l = b[j][2];    if (l &gt; 0) b[i][2] = l + 1;}for (int i = 1; i &lt;= n; i++)    maxx = max(maxx, b[i][2]);</code></pre><h2 id="快读模板"><a href="#快读模板" class="headerlink" title="快读模板"></a>快读模板</h2><hr><p>快读实际上就是不断读入字符，而后转化数值处理，它要比$cin$和$scanf$快很多  </p><pre><code>inline int read() {      int s = 0, f = 1;      char ch = getchar();      while(!isdigit(ch)) {          if(ch == &#39;-&#39;) f = -1;          ch = getchar();      }      while(isdigit(ch)) {          s = s * 10 + ch - &#39;0&#39;;          ch = getchar();      }      return s * f;  }  </code></pre><ul><li><p>$isdigit$函数头文件$<cctype>$</p></li><li><p>这里给出读入$int$类型时的模板，实际使用要根据数据范围改变函数类型</p></li></ul><hr><p>快写同理</p><pre><code>inline void write(int x) {      if(x &lt; 0) {          putchar(&#39;-&#39;);          x = -x;      }      if(x &gt; 9)          write(x/10);      putchar(x % 10 - &#39;0&#39;);      return;  }</code></pre><hr><ul><li>注意 在$VS$中使用$scanf$需要加#$define$ _CRT_SECURE_NO_WARNINGS这句话,所以快读快写在$VS$中会起到非常大的作用  </li></ul><h2 id="最短路模板"><a href="#最短路模板" class="headerlink" title="最短路模板"></a>最短路模板</h2><hr><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>$$O(n^3)$$</p><pre><code>for (int k = 1; k &lt;= n; k++)    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            if (dis[i][j] &gt; dis[i][k] + dis[k][j])                dis[i][j] = dis[i][k] + dis[k][j];</code></pre><h3 id="Dijkstra-STL堆优化"><a href="#Dijkstra-STL堆优化" class="headerlink" title="Dijkstra(+STL堆优化)"></a>Dijkstra(+STL堆优化)</h3><p>$$O((n+m)logm)$$</p><pre><code>void dijkstra(int start) {    que.push(make_pair(0, start));    dis[start] = 0;    while (!que.empty()) {        int tmp = que.top().second;        que.pop();        if (vis[tmp]) continue;        vis[tmp] = true;        for (int i = head[tmp]; i; i = edge[i].nxt) {            int v = edge[i].to, w = edge[i].dis;            if (!vis[v] &amp;&amp; dis[v] &gt; dis[tmp] + w)                dis[v] = dis[tmp] + w,                que.push(make_pair(-dis[v], v));        }    }}</code></pre><h3 id="SPFA-Bellman-Ford队列优化"><a href="#SPFA-Bellman-Ford队列优化" class="headerlink" title="SPFA(Bellman-Ford队列优化)"></a>SPFA(Bellman-Ford队列优化)</h3><p>$$O(nm)$$</p><pre><code>void Spfa() {    queue &lt;int&gt; que;    dis[start] = 0;    que.push(start);    while (!que.empty()) {        int tmp = que.front();        que.pop(); vis[tmp] = false;        for (i = head[tmp]; ~i; i = edge[i].nxt) {            int v = edge[i].to, w = edge[i].dis;            if (dis[v] &lt; dis[tmp] + w) continue;            dis[v] = dis[tmp] + w;            if (!vis[v])            vis[v] = true, que.push(v);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态更新的数论学习笔记</title>
      <link href="/2019/12/17/dong-tai-geng-xin-de-shu-lun-xue-xi-bi-ji/"/>
      <url>/2019/12/17/dong-tai-geng-xin-de-shu-lun-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><hr><hr><h2 id="因数"><a href="#因数" class="headerlink" title="因数"></a>因数</h2><ul><li>欧几里得算法：   <ul><li>求$a,b$最大公因数$gcd(a,b)$<br>太过简单，只给代码(llo为long\ long):  <pre class=" language-cpp"><code class="language-cpp">      llo <span class="token function">gcd</span><span class="token punctuation">(</span>llo a<span class="token punctuation">,</span> llo b<span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li><li>求$a,b$最小公倍数$lcm(a,b)$<br>$$lcm(a,b)=\frac{a*b}{gcd(a,b)}$$  </li></ul></li></ul><hr><ul><li>分解质因数<pre class=" language-cpp"><code class="language-cpp">      <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">1ll</span> <span class="token operator">*</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              p<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>              t<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">++</span>t<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">;</span> x <span class="token operator">/</span><span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span> p<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> t<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>从小到大枚举，对于任意质数，直接进行代码所示的枚 举而对于合数来说，它一定是由较小的质数组成，即使 原$x$ % (这个数) $==$ $0$，但$x$经过前面的处理已经将这个组  成这个合数的因子除掉了，自然当前$x$ % (这个数) $!=$ $0$</p></blockquote></li></ul><hr><ul><li><p>最小质因子：  </p><ul><li><p>求解方法：对筛法求素数代码进行改变  </p></li><li><p>代码：  </p><pre class=" language-cpp"><code class="language-cpp">      <span class="token function">memset</span><span class="token punctuation">(</span>sf<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">memset</span><span class="token punctuation">(</span>mindiv<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>mindiv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      n <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>          mindiv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>              f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mindiv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> mindiv<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span></code></pre><blockquote><p>对于每个数，由于是从小向大枚举，则它的最小质因子一定是最先能够筛掉它的数   </p></blockquote></li><li><p>利用最小质因子求出所有质因子：<br>  设$minx$为$x$的最小质因子，则显然$x = (x / minx) × minx$，设$miny$为$(x / minx)$的最小质因子，又有$(x / minx) = (x / minx / miny) × miny$这样递归下去即可求出$x$的所有质因子</p></li><li><p>$2$ ~ $n$每个数的质因子个数<br>  $$f[1] = 0, f[x] = f[x / mindivx] + 1$$</p></li><li><p>$2$ ~ $n$每个数的不同质因子个数<br>  $$f[1] = 0,f[x] = f[x / mindivx] + mindivx \mod  (x / mindivx) ? 0 : 1$$</p></li></ul></li></ul><hr><ul><li>快速求$1$~$n$所有数的因子：  <ul><li>$1$~$n$的因子总数为$nlogn$ $(n / 1 + n / 2 + n / 3 + n / 4 + …… n / n)$</li><li>代码：  <pre class=" language-cpp"><code class="language-cpp">      vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> div<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          div<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">)</span>              div<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span></code></pre><blockquote><p>类似于筛法思想，将当前数的所有倍数添加当前数为因子， 时间空间都是$O(nlogn)$的 </p></blockquote></li></ul></li></ul><hr><ul><li>精确的求某一个数的所有因子：质因数分解 $+$ 指数搜索<blockquote><p>例：$100 = 2^2 × 5^2$<br>因子：$2^0 × 5^0, 2^1 × 5^0……$  </p></blockquote></li></ul><hr><hr><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><ul><li>线性筛：<pre class=" language-cpp"><code class="language-cpp">      <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token function">memset</span><span class="token punctuation">(</span>sf<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>sf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>              sf<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span> sf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><blockquote><p>对于一个数，只要有一个质数将它筛去即可确定是合数，所以对于每个数$x$，将当前素数表里不大于$mindivx$的数与$x$的乘积筛掉，而大于$mindivx$的质数与$x$的乘积必定会在之后被大于x的数筛掉，减小了筛的次数，达到线性的复杂度 $(注意两个break的次序和位置)$，适用于$n &gt; 1e7$的数据范围  </p></blockquote></li></ul><hr><hr><h2 id="一些我不知道怎么分类但是非常强大的算法"><a href="#一些我不知道怎么分类但是非常强大的算法" class="headerlink" title="一些我不知道怎么分类但是非常强大的算法"></a>一些我不知道怎么分类但是非常强大的算法</h2><ul><li><p>扩展欧几里得算法$(exgcd)$：  </p><ul><li><p><del>我自闭了</del>  </p></li><li><p>对扩欧的理解：  </p><p>给出不定方程,形如  </p><p>$$ax+by=c$$  </p><p>满足条件的<strong>整数解</strong>$x,y$有很多(<del>废话</del>)，当且仅当$gcd(a,b)|c$时方程有整数解   </p><blockquote><p>证明：<br>方程两边同时除以$gcd(a,b)$    </p></blockquote><p>$$\frac{a}{gcd(a,b)}* x+\frac{b}{gcd(a,b)}*y=\frac{c}{gcd(a,b)}$$</p><blockquote><p>观察等式，等式左边为一整数，故等式右边亦为一整数<br>所以  </p></blockquote><p>$$gcd(a,b)|c$$  </p><blockquote><p>证毕  </p></blockquote><p>因此，可以转化为求一组$x,y$，满足$ax+by=gcd(a,b)$，在求解原方程等式两边同时乘以$\frac{c}{gcd(a,b)}$即可<br>对于求解$ax+by=gcd(a,b)$，可以找出一组$x0,y0$<br>使<br>$$ax_0+by_0=gcd(a,b)$$<br>进而表达出通解公式：  </p><p>$$x=x_0+t*\frac{b}{gcd(a,b)}$$  </p><p>$$\qquad \qquad \quad y=y_0-t*\frac{a}{gcd(a,b)},\quad\forall t\in Z$$  </p><blockquote><p>推导过程：<br>$$ax_0 + by_0$$<br>$$=ax_0+\frac{a* b}{gcd(a,b)}+by_0-\frac{b* a}{gcd(a,b)}$$<br>$$=a(x_0+\frac{b}{gcd(a,b)})+b(y_0-\frac{a}{gcd(a,b)})$$<br>$$ax+by=a(x_0+t* \frac{b}{gcd(a,b)})+b(y_0-t* \frac{a}{gcd(a,b)}),\quad \forall t\in Z$$<br>因此，若要表达其它满足方程的$x,y$<br>$$x=x_0+t* \frac{b}{gcd(a,b)}$$<br>$$\qquad \qquad \quad y=y_0-t*\frac{a}{gcd(a,b)},\quad\forall t\in Z$$<br>推毕   </p></blockquote><p>那么只需要求出一组特解$x_0,y_0$就好了，而求解特解，便是扩欧算法的核心所在<br>代码(<del>因为怂</del>都开了$long\ long$)：    </p><pre class=" language-cpp"><code class="language-cpp">  llo <span class="token function">exgcd</span><span class="token punctuation">(</span>llo a<span class="token punctuation">,</span> llo b<span class="token punctuation">,</span> llo <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> llo y<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span>      llo gcd <span class="token operator">=</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>      llo z <span class="token operator">=</span> x<span class="token punctuation">,</span> x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> z <span class="token operator">-</span> y <span class="token operator">*</span> <span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> gcd<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><blockquote><p>解释：<br>在欧几里得算法中，每一个状态$a,b$的下一个状态是$b,a\mod b$<br>假设当前状态的下一个状态中已经求解出一组$x_1,y_1$<br>$$b* x_1+a\mod b* y_1=gcd(a,b)$$<br>因为<br>$$a\mod b=a-(a/b)* b$$<br>所以<br>$$b* x_1+(a-(a/ b)* b)* y1=gcd(a,b)$$<br>$$b* x_1-(a/b)* b* y_1+a* y_1=gcd(a,b)$$<br>$$a* y_1+b[x_1-(a/b)* y_1]=gcd(a,b)$$<br>那么在递归返回时可令<br>$$x=y1,y=x_1-(a/b)* y_1$$<br>欧几里得算法停止的状态，$b=0$，此时时$a$即为$gcd(a,b)$  若使$a$的系数为$1$那么$b$的系数y便无关紧要了<br>$$1* gcd(a,b)+k* 0=gcd(a,b)$$<br>所以<br>$$if(!b),x=1,y=k\quad \forall k\in Z$$<br>为了方便使$y=0$<br>注意：$x,y$是传址调用，否则无法起到递归返回时修改的目的   </p></blockquote><p>$exgcd$算法的流程便结束了    </p></li><li><p>exgcd的应用：  </p><ul><li><p>求最小整数解：  </p><p>回顾原方程：<br>$$ax+by=gcd(a,b)$$<br>$x$的最小整数解$min_x=x\mod  \frac{b}{gcd(a,b)}$  </p><blockquote><p>推导：<br>假设$exgcd$求出原方程的一组解为$x_0,y_0$<br>由于解集之间可以相互转化<br>$$x_0=min_x+t*\frac{b}{gcd(a,b)}$$<br>要求解$min_x$只需要$x_0\mod \frac{b}{gcd(a,b)}$即可  </p></blockquote></li><li><p>求解$a$在$mod\ p$意义下的逆元(a^{-1})：  </p><blockquote><p>逆元：<br>对于一个实数$a$，如果存在一个$x$使得 $ax=1$，我们就把这个$x$叫做$a$的逆元，记做$x=a^{-1}$<br>在一般数学中，我们所说的逆元就是倒数。<br>在数论中，如果数字$a$存在一个对$p$的逆元$x$，可以写成$ax\equiv 1\ (mod\ p)$，$gcd(a,p)=1$，否则不存在逆元</p></blockquote><p>设$a^{-1}$为$x$，原式转化为<br>$$ax\equiv 1\ (mod\ p)$$<br>进而转化为<br>$$ax+py=1$$<br>$exgcd$解决  </p><p>代码(exgcd求解出的x是负数，return时需要处理)：</p><pre class=" language-cpp"><code class="language-cpp">  llo <span class="token function">inv</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>      llo x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> p <span class="token operator">+</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre></li><li><p>线性同余方程：  </p><p>一般形式<br>$$ax\equiv b\ (mod\ p)$$<br>对此一定有$b&lt;p$，而$b&gt;p$时可先对$b$取模，等效<br>式子可转化<br>$$ax-kp=b$$<br>$exgcd$求解  </p></li></ul></li><li><p>例题：  </p><ul><li><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">$luogu\ p1082$ 同余方程</a> ：模板题  </li><li><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">$luogu\ p1516$ 青蛙的约会</a> ：先列出式子，套$exgcd$  </li></ul></li></ul></li></ul><hr><ul><li><p>费马小定理：  </p><ul><li><p>定义：若$p$为一质数，则$a^{p-1}\equiv 1\ (mod\ p)$  </p></li><li><p>费马小定理求逆元：  </p><p>由定义上式可转化为<br>$$a*a^{p-2}\equiv 1\ (mod\ p)$$<br>因此$a^{p-2}$即为$a$在$mod\ p$意义下的逆元<br>可以直接用快速幂求解   </p></li></ul></li></ul><hr><ul><li>高斯消元：  <ul><li>定义</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
